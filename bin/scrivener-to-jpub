#!/usr/bin/env ruby
require 'rubygems'
require 'bundler/setup'

require 'nokogiri'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'yaml'

CONTENT_DIR_NAME = 'content'
LISTING_FILE_NAME = "#{CONTENT_DIR_NAME}.yaml"

class CommandLine
  def self.parse
    options = {}

    parser = OptionParser.new do |opts|
      opts.banner << ' file dir'

      opts.on_tail('-h', '--help', 'print this message') do
        puts opts
        exit
      end
    end

    parser.parse! ARGV

    unless ARGV.length == 2
      puts parser
      exit
    end

    options[:scrivener_file] = Pathname(ARGV[0])
    options[:output_dir] = Pathname(ARGV[1])

    unless options[:scrivener_file].directory?
      puts "No such Scrivener file: #{options.scrivener_file}"
      exit
    end

    options
  end
end

class Document
  attr_reader :id, :path

  def initialize(node:, parent_path:, position:)
    @id = node['ID'].to_i
    @title = node.at_xpath('./Title').content
    @type = node['Type']
    slug = @title.gsub(/\s+/, '-').gsub(/[^[:alnum:]-]/, '').downcase
    @path = parent_path / slug
    @custom_metadata = custom_metadata(node)
    @position = position
  end

  def header
    {
      'id' => @id,
      'title' => @title,
      'type' => @type,
      'depth' => @path.to_s.split('/').size,
      'position' => @position
    }.merge(@custom_metadata)
  end

  private

  def custom_metadata(node)
    node.xpath('./MetaData/CustomMetaData/MetaDataItem').inject({}) do |fields, field|
      id = field.at_xpath('./FieldID').content
      value = field.at_xpath('./Value').content
      fields[id] = value
      fields
    end
  end
end

class ScrivenerToMarkdown
  def initialize(scrivener)
    @scrivener = scrivener
    @docs = @scrivener.path / 'Files' / 'Docs'
  end

  def write_to(content_dir)
    @scrivener.documents.each { |document| write(content_dir: content_dir, document: document) }
  end

  def write(content_dir:, document:)
    md_path = content_dir / "#{document.path}.md"
    md_path.parent.mkpath

    content = StringIO.new
    content.puts document.header.to_yaml
    content.puts '---'
    rtf_path = rtf_path(document)
    content.puts to_markdown(rtf_path) if rtf_path.file?
    md_path.write(content.string)
  end

  def to_markdown(rtf_path)
    %x{ textutil -convert html -excludedelements '(span)' -strip -stdout #{rtf_path} | pandoc -f html -t markdown }
  end

  def rtf_path(document)
    @docs / "#{document.id}.rtf"
  end
end

class Scrivener
  attr_reader :documents, :path
  def initialize(path)
    @path = Pathname(path)
    basename = path.basename
    scrivx_path = path / basename.sub_ext('.scrivx')
    raise "Cannot read SCRIVX file: #{scrivx_path}" unless scrivx_path.exist?
    scrivx_file = scrivx_path.open
    scrivx = Nokogiri::XML(scrivx_file)

    @metadata_fields = scrivx.xpath('.//CustomMetaDataSettings/MetaDataField').inject({}) do |fields, field|
      fields[field['ID']] = field.content
      fields
    end

    root = OpenStruct.new 'path' => Pathname.new('')
    @documents = []
    gather_documents(documents: @documents, parent_node: scrivx.xpath('.//BinderItem[@ID="0"]'), parent_document: root)
  end

  private

  def gather_documents(documents:, parent_node:, parent_document:)
    parent_node.xpath('./Children/BinderItem').each_with_index do |node, index|
      document = Document.new(node: node, parent_path: parent_document.path, position: index + 1)
      documents << document
      gather_documents(documents: documents, parent_node: node, parent_document: document)
    end
  end
end

class Listing
  def initialize(scrivener)
    @paths = scrivener.documents.map{ |document|
        path = document.path
        dir = path.dirname
        basename = path.basename
        "#{dir / basename}.html"
    }
  end

  def write_to(output_dir)
    content = @paths
      .map{|path| "- #{CONTENT_DIR_NAME}/#{path}" }
      .join("\n")

    output_dir.mkpath
    listing_file = output_dir / LISTING_FILE_NAME
    listing_file.write(content)
  end

  private
end

options = CommandLine.parse
scrivener = Scrivener.new(options[:scrivener_file])

puts scrivener.documents.map { |document| document.header }

output_dir = options[:output_dir]

Listing.new(scrivener).write_to(output_dir)
ScrivenerToMarkdown.new(scrivener).write_to(output_dir / CONTENT_DIR_NAME)
